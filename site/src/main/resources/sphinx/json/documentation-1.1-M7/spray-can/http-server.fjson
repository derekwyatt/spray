{"body": "<div class=\"section\" id=\"httpserver\">\n<span id=\"id1\"></span><h1>HttpServer</h1>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> is an embedded, low-level, low-overhead, high-performance, fully asynchronous,\nnon-blocking and actor-based HTTP/1.1 server implemented on top of <a class=\"reference internal\" href=\"../../spray-io/#spray-io\"><em>spray-io</em></a>.</p>\n<p>It sports the following features:</p>\n<ul class=\"simple\">\n<li>Low per-connection overhead for supporting many thousand concurrent connections</li>\n<li>Efficient message parsing and processing logic for high throughput applications (&gt; 40K requests/sec on ordinary\nconsumer hardware)</li>\n<li>Full support for <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/HTTP_persistent_connection\">HTTP persistent connections</a></li>\n<li>Full support for <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/HTTP_pipelining\">HTTP pipelining</a></li>\n<li>Full support for asynchronous HTTP streaming (i.e. &#8220;chunked&#8221; transfer encoding)</li>\n<li>Optional SSL/TLS encryption</li>\n<li>Actor-based architecture for easy integration into your Akka applications</li>\n</ul>\n<div class=\"section\" id=\"design-philosophy\">\n<h2>Design Philosophy</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> is scoped with a clear focus on the essential functionality of an HTTP/1.1 server:</p>\n<ul class=\"simple\">\n<li>Connection management</li>\n<li>Message parsing and header separation</li>\n<li>Timeout management (for requests and connections)</li>\n<li>Response ordering (for transparent pipelining support)</li>\n</ul>\n<p>All non-core features of typical HTTP servers (like request routing, file serving, compression, etc.) are left to\nthe next layer in the application stack, they are not implemented by <em>spray-can</em> itself.\nApart from general focus this design keeps the server small and light-weight as well as easy to understand and\nmaintain. It also makes a <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> a perfect &#8220;container&#8221; for a <a class=\"reference internal\" href=\"../../spray-routing/#spray-routing\"><em>spray-routing</em></a> application,\nsince <em>spray-can</em> and <em>spray-routing</em> nicely complement and interface into each other.</p>\n</div>\n<div class=\"section\" id=\"basic-architecture\">\n<h2>Basic Architecture</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> is implemented as an Akka actor, which talks to an underlying <a class=\"reference internal\" href=\"../../spray-io/io-bridge/#iobridge\"><em>IOBridge</em></a> and spawns\nnew child actors for every new connection. These connection actors process the requests coming in across the connection\nand dispatch them as immutable <a class=\"reference internal\" href=\"../../spray-http/#spray-http\"><em>spray-http</em></a> <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> instances to a &#8220;handler&#8221; actor provided by the\napplication. The handler completes a request by simply replying with an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">receive</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"nc\">HttpRequest</span><span class=\"o\">(</span><span class=\"nc\">GET</span><span class=\"o\">,</span> <span class=\"s\">&quot;/ping&quot;</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span>\n    <span class=\"n\">sender</span> <span class=\"o\">!</span> <span class=\"nc\">HttpResponse</span><span class=\"o\">(</span><span class=\"n\">entity</span> <span class=\"k\">=</span> <span class=\"s\">&quot;PONG&quot;</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>Additionally the handler is informed of the closing of connections, the successful sending of responses (optionally)\nas well as any errors occurring on the network side (the details of which are explained in the <a class=\"reference internal\" href=\"#message-protocol\">Message Protocol</a>\nsection below).</p>\n<p>The following types of handlers are supported:</p>\n<dl class=\"docutils\">\n<dt>Singleton Handlers</dt>\n<dd>The application dedicates a single, long-lived actor for handling all requests.</dd>\n<dt>Per-Connection Handlers</dt>\n<dd>The application provides a new handler actor for every new incoming connection.</dd>\n<dt>Per-Message Handlers</dt>\n<dd>The application provides a new handler actor for every new incoming request.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"starting-and-stopping\">\n<h2>Starting and Stopping</h2>\n<p>Since the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> is a regular actor it is started and stopped like any other one.\nThe <a class=\"reference internal\" href=\"../examples/#simple-http-server\"><em>simple-http-server</em></a> example contains a complete and working code example.</p>\n</div>\n<div class=\"section\" id=\"message-protocol\">\n<h2>Message Protocol</h2>\n<p>A running <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> actor understands the following command messages\n(they are all defined in the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/server/HttpServer.scala\">HttpServer</a> companion object):</p>\n<dl class=\"docutils\">\n<dt>Bind</dt>\n<dd>Start listening for incoming connections on a particular port. The sender receives a <tt class=\"docutils literal\"><span class=\"pre\">Bound</span></tt> event upon completion.</dd>\n<dt>Unbind</dt>\n<dd>Revert a previous <tt class=\"docutils literal\"><span class=\"pre\">Bind</span></tt>. The sender receives an <tt class=\"docutils literal\"><span class=\"pre\">Unbound</span></tt> event upon completion.</dd>\n<dt>GetStats</dt>\n<dd>Send the sender an <tt class=\"docutils literal\"><span class=\"pre\">HttpServer.Stats</span></tt> message containing simple server statistics.</dd>\n<dt>ClearStats</dt>\n<dd>Reset the server statistics.</dd>\n</dl>\n<div class=\"section\" id=\"request-response-cycle\">\n<h3>Request-Response Cycle</h3>\n<p>After having bound to an interface/port the server spawns a new connection actor for every new connection.\nAs soon as a new request has been successfully read from the connection it is dispatched to the handler actor\nprovided as argument to the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> constructor. The handler actor processes the request according\nto the application logic and responds by sending an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance to the <tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> of the request.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of an <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> received by the handler is unique to the\nrequest, i.e. several requests, even when coming in across the same connection, will appear to be sent from different\nsenders. <em>spray-can</em> uses these sender <tt class=\"docutils literal\"><span class=\"pre\">ActorRefs</span></tt> to coalesce the response with the request, so you cannot send\nseveral responses to the same sender. However, the different request parts of chunked requests arrive from the same\nsender, and the different response parts of a chunked response need to be sent to the same sender as well.</p>\n<div class=\"admonition caution\">\n<p class=\"first admonition-title\">Caution</p>\n<p class=\"last\">Since the <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of a request is an <a class=\"reference internal\" href=\"../../spray-util/#unregisteredactorref\"><em>UnregisteredActorRef</em></a> it is not\nreachable remotely. This means that the actor designated as handler by the application needs to live in the same\nJVM as the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"chunked-requests\">\n<h3>Chunked Requests</h3>\n<p>If the <tt class=\"docutils literal\"><span class=\"pre\">request-chunk-aggregation-limit</span></tt> config setting is set to zero the server also dispatches the individual\nrequest parts of chunked requests to the handler actor. In these cases a full request consists of the following\nmessages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request handling timeouts (if configured to non-zero) only starts running when the final\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> message was dispatched to the handler.</p>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h3>Chunked Responses</h3>\n<p>Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance the handler can choose to respond to the request sender with the\nfollowing sequence of individual messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request handling timeouts (if configured to non-zero) will stop running as soon as the initial\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> message has been received from the handler, i.e. there is currently no timeout checking\nfor and in between individual response chunks.</p>\n</div>\n<div class=\"section\" id=\"request-timeouts\">\n<h3>Request Timeouts</h3>\n<p>If the handler does not respond to a request within the configured <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt> period a\n<tt class=\"docutils literal\"><span class=\"pre\">spray.http.Timeout</span></tt> message is sent to the timeout handler, which can be the &#8220;regular&#8221; handler itself or\nanother actor (depending on the <tt class=\"docutils literal\"><span class=\"pre\">timeout-handler</span></tt> config setting). The timeout handler then has the chance to\ncomplete the request within the time period configured as <tt class=\"docutils literal\"><span class=\"pre\">timeout-timeout</span></tt>. Only if the timeout handler also misses\nits deadline for completing the request will the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> complete the request itself with a &#8220;hard-coded&#8221; error\nresponse (which you can change by overriding the <tt class=\"docutils literal\"><span class=\"pre\">timeoutResponse</span></tt> method).</p>\n</div>\n<div class=\"section\" id=\"send-confirmations\">\n<span id=\"httpserver-send-confirmations\"></span><h3>Send Confirmations</h3>\n<p>If required the server can reply with a &#8220;send confirmation&#8221; message to every response (part) coming in from the\nhandler. You request a send confirmation by modifying a response part with the <tt class=\"docutils literal\"><span class=\"pre\">withSentAck</span></tt> method. For example,\nthe following handler logic receives the String &#8220;ok&#8221; as an actor message after the response has been successfully\nwritten to the connections socket:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">receive</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"nc\">HttpRequest</span><span class=\"o\">(</span><span class=\"nc\">GET</span><span class=\"o\">,</span> <span class=\"s\">&quot;/ping&quot;</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span>\n    <span class=\"n\">sender</span> <span class=\"o\">!</span> <span class=\"nc\">HttpResponse</span><span class=\"o\">(</span><span class=\"n\">entity</span> <span class=\"k\">=</span> <span class=\"s\">&quot;PONG&quot;</span><span class=\"o\">).</span><span class=\"n\">withSentAck</span><span class=\"o\">(</span><span class=\"s\">&quot;ok&quot;</span><span class=\"o\">)</span>\n\n  <span class=\"k\">case</span> <span class=\"s\">&quot;ok&quot;</span> <span class=\"k\">=&gt;</span> <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;Response was sent successfully&quot;</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>Confirmation messages are especially helpful for triggering the sending of the next response part in a response\nstreaming scenario, since with such a design the application will never produce more data than the network can handle.</p>\n<p>Send confirmations are always dispatched to the actor, which sent the respective response (part).</p>\n</div>\n<div class=\"section\" id=\"closed-notifications\">\n<h3>Closed Notifications</h3>\n<p>When a connection is closed, for whatever reason, the server dispatches a <tt class=\"docutils literal\"><span class=\"pre\">Closed</span></tt> event message to the application.\nExactly which actor receives it depends on the current state of request processing.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> sends <tt class=\"docutils literal\"><span class=\"pre\">Closed</span></tt> events coming in from the underlying <a class=\"reference internal\" href=\"../../spray-io/io-bridge/#iobridge\"><em>IOBridge</em></a> to</p>\n<ul class=\"simple\">\n<li>the handler actor, if no request is currently open and the application doesn&#8217;t use <tt class=\"docutils literal\"><span class=\"pre\">Per-Message</span></tt> handlers.</li>\n<li>the handler actor, if a request is currently open and no response part has yet been received.</li>\n<li>the sender of the last response part received by the server if the part is a <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> or a\n<tt class=\"docutils literal\"><span class=\"pre\">MessageChunk</span></tt>.</li>\n<li>the sender of the last response part received if a send confirmation was requested but not dispatched.</li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The application can always choose to actively close a connection by sending a <tt class=\"docutils literal\"><span class=\"pre\">Close</span></tt> command to the sender\nof a request. However, during normal operation it is encouraged to make use of the <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header to signal\nto the server whether or not the connection is to be closed after the response has been sent.</p>\n</div>\n</div>\n<div class=\"section\" id=\"connection-configuration\">\n<h3>Connection Configuration</h3>\n<p>After having received a request the applications request handler can send the following configuration messages to the\n<tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> in order to change config setting <em>for that connection only</em>:</p>\n<dl class=\"docutils\">\n<dt>SetIdleTimeout</dt>\n<dd>Change the connections <tt class=\"docutils literal\"><span class=\"pre\">idle-timeout</span></tt>.</dd>\n<dt>SetRequestTimeout</dt>\n<dd>Change the connections <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt>.</dd>\n<dt>SetTimeoutTimeout</dt>\n<dd>Change the connections <tt class=\"docutils literal\"><span class=\"pre\">timeout-timeout</span></tt>.</dd>\n</dl>\n<p>All these command messages are defined in the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> companion object.</p>\n</div>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> always passes all received headers on to the application. Additionally the values of the\nfollowing request headers are interpreted by the server itself:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Expect</span></tt> (the only supported expectation is &#8220;100-continue&#8221;)</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Host</span></tt> (only the presence of this header is verified)</li>\n</ul>\n<p>All other headers are of no interest to the server layer.</p>\n<p>When sending out responses the server watches for a <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header set by the application and acts\naccordingly, i.e. you can force the server to close the connection after having sent the response by including a\n<tt class=\"docutils literal\"><span class=\"pre\">Connection(&quot;close&quot;)</span></tt> header. To unconditionally force a connection keep-alive you can explicitly set a\n<tt class=\"docutils literal\"><span class=\"pre\">Connection(&quot;Keep-Alive&quot;)</span></tt> header. If you don&#8217;t set an explicit <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header the server will keep the\nconnection alive if the client supports this (i.e. it either sent a <tt class=\"docutils literal\"><span class=\"pre\">Connection:</span> <span class=\"pre\">Keep-Alive</span></tt> header or advertised\nHTTP/1.1 capabilities without sending a <tt class=\"docutils literal\"><span class=\"pre\">Connection:</span> <span class=\"pre\">close</span></tt> header).</p>\n<p>If your <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instances include any of the following headers they will be ignored and <em>not</em> rendered into\nthe response going out to the client (as the server sets these response headers itself):</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Date</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Server</span></tt></li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> <em>sprays</em> higher layers\n(like <em>spray-routing</em>) only work with the Content-Type value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"id3\">\n<h2>HTTP Pipelining</h2>\n<p><em>spray-can</em> fully supports HTTP pipelining. If the configured <tt class=\"docutils literal\"><span class=\"pre\">pipelining-limit</span></tt> is greater than one the server will\naccept several requests in a row (coming in across a single connection) and dispatch them to the application before the\nfirst one has been responded to. This means that several requests will potentially be handled by the application at the\nsame time.</p>\n<p>Since in many asynchronous applications request handling times can be somewhat undeterministic <em>spray-can</em> takes care of\nproperly ordering all responses coming in from your application before sending them out to &#8220;the wire&#8221;.\nI.e. your application will &#8220;see&#8221; requests in the order they are coming in but is <em>not</em> required to itself uphold this\norder when generating responses.</p>\n</div>\n<div class=\"section\" id=\"ssl-support\">\n<h2>SSL Support</h2>\n<p>If enabled via the <tt class=\"docutils literal\"><span class=\"pre\">ssl-encryption</span></tt> config setting the <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> requires all incoming connections to\nbe SSL/TLS encrypted. The constructor of the <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> actor takes an implicit argument of type\n<tt class=\"docutils literal\"><span class=\"pre\">ServerSSLEngineProvider</span></tt>, which is essentially a function <tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">SSLEngine</span></tt>.\nWhenever a new connection has been accepted the server uses the given function to create an <tt class=\"docutils literal\"><span class=\"pre\">javax.net.ssl.SSLEngine</span></tt>\nfor the connection.</p>\n<p>If you&#8217;d like to apply some custom configuration to your <tt class=\"docutils literal\"><span class=\"pre\">SSLEngine</span></tt> instances an easy way would be to bring a custom\nengine provider into scope, e.g. like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">myEngineProvider</span> <span class=\"k\">=</span> <span class=\"nc\">ServerSSLEngineProvider</span> <span class=\"o\">{</span> <span class=\"n\">engine</span> <span class=\"k\">=&gt;</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledCipherSuites</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledProtocols</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;SSLv3&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;TLSv1&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>EngineProvider creation also relies on an implicitly available <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt>, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">SSLContextProvider</span> <span class=\"k\">extends</span> <span class=\"o\">(</span><span class=\"nc\">PipelineContext</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">SSLContext</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>The default <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt> simply provides an implicitly available &#8220;constant&#8221; <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>, by default the\n<tt class=\"docutils literal\"><span class=\"pre\">SSLContext.getDefault</span></tt> is used. This means that the easiest way to have the server use a custom <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>\nis to simply bring one into scope implicitly:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">mySSLContext</span><span class=\"k\">:</span> <span class=\"kt\">SSLContext</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">context</span> <span class=\"k\">=</span> <span class=\"nc\">SSLContext</span><span class=\"o\">.</span><span class=\"n\">getInstance</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS&quot;</span><span class=\"o\">)</span>\n  <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"o\">(...)</span>\n  <span class=\"n\">context</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"spraycanhttpserverapp-trait\">\n<span id=\"spraycanhttpserverapp\"></span><h2>SprayCanHttpServerApp trait</h2>\n<p>In many cases the bootstrapping logic for starting an <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> application is almost identical:</p>\n<ol class=\"arabic simple\">\n<li>Create an <tt class=\"docutils literal\"><span class=\"pre\">ActorSystem</span></tt></li>\n<li>Create and start application level actors</li>\n<li>Create and start an <a class=\"reference internal\" href=\"../../spray-io/io-bridge/#iobridge\"><em>IOBridge</em></a></li>\n<li>Create and start an <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> instance</li>\n<li>Send the server a <tt class=\"docutils literal\"><span class=\"pre\">Bind</span></tt> message.</li>\n</ol>\n<p>In order to reduce boilerplate and increase DRYness <em>spray-can</em> comes with the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/server/SprayCanHttpServerApp.scala\">SprayCanHttpServerApp</a> trait,\nwhich allows you to simplify your boot class to something like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">spray.can.server.SprayCanHttpServerApp</span>\n\n<span class=\"k\">object</span> <span class=\"nc\">Main</span> <span class=\"k\">extends</span> <span class=\"nc\">App</span> <span class=\"k\">with</span> <span class=\"nc\">SprayCanHttpServerApp</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">handler</span> <span class=\"k\">=</span> <span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">actorOf</span><span class=\"o\">(</span><span class=\"nc\">Props</span><span class=\"o\">[</span><span class=\"kt\">MyService</span><span class=\"o\">])</span>\n  <span class=\"n\">newHttpServer</span><span class=\"o\">(</span><span class=\"n\">handler</span><span class=\"o\">)</span> <span class=\"o\">!</span> <span class=\"nc\">Bind</span><span class=\"o\">(</span><span class=\"n\">interface</span> <span class=\"k\">=</span> <span class=\"s\">&quot;localhost&quot;</span><span class=\"o\">,</span> <span class=\"n\">port</span> <span class=\"k\">=</span> <span class=\"mi\">8080</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>If you have special needs with regard to your <tt class=\"docutils literal\"><span class=\"pre\">ActorSystem</span></tt> you can create it yourself and still rely on the\n<tt class=\"docutils literal\"><span class=\"pre\">SprayCanHttpServerApp</span></tt> trait by overriding the <tt class=\"docutils literal\"><span class=\"pre\">system</span></tt> member as such:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">override</span> <span class=\"k\">lazy</span> <span class=\"k\">val</span> <span class=\"n\">system</span> <span class=\"k\">=</span> <span class=\"nc\">ActorSystem</span><span class=\"o\">(...)</span>\n</pre></div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "HttpServer", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-can/http-server", "next": {"link": "../http-client/", "title": "HttpClient"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/http-client", "HttpClient", "N", "next"], ["documentation/spray-can/configuration", "Configuration", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-can"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">HttpServer</a><ul>\n<li><a class=\"reference internal\" href=\"#design-philosophy\">Design Philosophy</a></li>\n<li><a class=\"reference internal\" href=\"#basic-architecture\">Basic Architecture</a></li>\n<li><a class=\"reference internal\" href=\"#starting-and-stopping\">Starting and Stopping</a></li>\n<li><a class=\"reference internal\" href=\"#message-protocol\">Message Protocol</a><ul>\n<li><a class=\"reference internal\" href=\"#request-response-cycle\">Request-Response Cycle</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-requests\">Chunked Requests</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#request-timeouts\">Request Timeouts</a></li>\n<li><a class=\"reference internal\" href=\"#send-confirmations\">Send Confirmations</a></li>\n<li><a class=\"reference internal\" href=\"#closed-notifications\">Closed Notifications</a></li>\n<li><a class=\"reference internal\" href=\"#connection-configuration\">Connection Configuration</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#id3\">HTTP Pipelining</a></li>\n<li><a class=\"reference internal\" href=\"#ssl-support\">SSL Support</a></li>\n<li><a class=\"reference internal\" href=\"#spraycanhttpserverapp-trait\">SprayCanHttpServerApp trait</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../configuration/", "title": "Configuration"}, "metatags": ""}