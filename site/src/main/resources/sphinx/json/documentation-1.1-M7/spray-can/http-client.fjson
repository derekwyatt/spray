{"body": "<div class=\"section\" id=\"httpclient\">\n<span id=\"id1\"></span><h1>HttpClient</h1>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> is a low-level, low-overhead, high-performance, fully asynchronous,\nnon-blocking and actor-based HTTP/1.1 client implemented on top of <a class=\"reference internal\" href=\"../../spray-io/#spray-io\"><em>spray-io</em></a>.</p>\n<p>It is the counterpart of the <a class=\"reference internal\" href=\"../http-server/#httpserver\"><em>HttpServer</em></a> and shares all core features as well as the basic\n&#8220;low-level&#8221; philosophy with the server.</p>\n<div class=\"section\" id=\"basic-architecture\">\n<h2>Basic Architecture</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> is implemented as an Akka actor, which talks to an underlying <a class=\"reference internal\" href=\"../../spray-io/io-bridge/#iobridge\"><em>IOBridge</em></a> and spawns\nnew child actors for every new connection. These connection actors render the outgoing requests, process the incoming\nresponses and dispatch them back to the application.</p>\n<p>One <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> instance can handle many thousand concurrent requests, so normally there is no reason to instantiate\nmore than one <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> per application. However, since its overhead is small it&#8217;s not a problem if you do.\n(One reason might be that you need several clients with different configurations.)</p>\n</div>\n<div class=\"section\" id=\"starting-and-stopping\">\n<h2>Starting and Stopping</h2>\n<p>Since the <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> is a regular actor it is started and stopped like any other one.\nThe <a class=\"reference internal\" href=\"../examples/#simple-http-client\"><em>simple-http-client</em></a> example contains a complete and working code example.</p>\n</div>\n<div class=\"section\" id=\"message-protocol\">\n<h2>Message Protocol</h2>\n<p>After having started an <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> you typically send it a <tt class=\"docutils literal\"><span class=\"pre\">Connect</span></tt> command message (all commands are defined\nin the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/client/HttpClient.scala\">HttpClient</a> companion object). The client will attempt to connect to the target server and either respond with\nan <tt class=\"docutils literal\"><span class=\"pre\">HttpClient.Connected</span></tt> event after the connection has been established, or a <tt class=\"docutils literal\"><span class=\"pre\">Status.Failure</span></tt> message\n(which is automatically turned into Future failures if the <tt class=\"docutils literal\"><span class=\"pre\">Connect</span></tt> was sent with an <tt class=\"docutils literal\"><span class=\"pre\">ask</span></tt>).</p>\n<p>After the connection has been established the application then sends an <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> to the sender of the\n<tt class=\"docutils literal\"><span class=\"pre\">Connected</span></tt> message (which is the connection actor responsible for the connection). After having received and parsed\nthe response the connection actor then replies with the <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance to the sender of the request\n(which might be a Future if the <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> was sent with an <tt class=\"docutils literal\"><span class=\"pre\">ask</span></tt>).</p>\n<p>The application can then decide to send another request across the same connection (reusing the connection actor) or\nclose the connection by sending <tt class=\"docutils literal\"><span class=\"pre\">Close</span></tt> command to the connection actor.</p>\n<div class=\"section\" id=\"chunked-requests\">\n<h3>Chunked Requests</h3>\n<p>Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> the application can choose to send this sequence of individual messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> will render these as one logical HTTP request with the <tt class=\"docutils literal\"><span class=\"pre\">chunked</span></tt> transfer-encoding.\nThe timer for checking request timeouts (if configured to non-zero) only starts running when the final\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> message was sent out.</p>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h3>Chunked Responses</h3>\n<p>If the <tt class=\"docutils literal\"><span class=\"pre\">response-chunk-aggregation-limit</span></tt> config setting is set to zero the client also dispatches the individual\nresponse parts of chunked requests back to the application. In these cases a full response consists of the following\nmessages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request timeouts (if configured to non-zero) will stop running as soon as the initial\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> message has been received, i.e. there is currently no timeout checking\nfor and in between individual response chunks.</p>\n</div>\n<div class=\"section\" id=\"request-timeouts\">\n<h3>Request Timeouts</h3>\n<p>If no response to a request is received within the configured <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt> period the <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> closes\nthe connection, upon which the application receives a <tt class=\"docutils literal\"><span class=\"pre\">Closed(RequestTimeout)</span></tt> event message.</p>\n</div>\n<div class=\"section\" id=\"send-confirmations\">\n<h3>Send Confirmations</h3>\n<p>If required the client can reply with a &#8220;send confirmation&#8221; message to every request (part) received by the application.\nYou request a send confirmation by modifying a request part with the <tt class=\"docutils literal\"><span class=\"pre\">withSentAck</span></tt> method (see the server-side\n<a class=\"reference internal\" href=\"../http-server/#httpserver-send-confirmations\"><em>Send Confirmations</em></a> section for example code).\nConfirmation messages are especially helpful for triggering the sending of the next request part in a request\nstreaming scenario, since with such a design the application will never produce more data than the network can handle.</p>\n<p>Send confirmations are always dispatched to the actor, which sent the respective request (part).</p>\n</div>\n<div class=\"section\" id=\"closed-notifications\">\n<h3>Closed Notifications</h3>\n<p>When a connection is closed, for whatever reason, the <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> dispatches a <tt class=\"docutils literal\"><span class=\"pre\">Closed</span></tt> event message to the\napplication. This message carries a <tt class=\"docutils literal\"><span class=\"pre\">reason</span></tt> member whose possible values are define <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-io/src/main/scala/spray/io/ConnectionCloseReasons.scala\">here</a>.</p>\n</div>\n<div class=\"section\" id=\"connection-configuration\">\n<h3>Connection Configuration</h3>\n<p>After having received the <tt class=\"docutils literal\"><span class=\"pre\">Connected</span></tt> message the applications can send the following configuration messages to the\n<tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> (i.e. the connection actor) in order to change config setting <em>for that connection only</em>:</p>\n<dl class=\"docutils\">\n<dt>SetIdleTimeout</dt>\n<dd>Change the connections <tt class=\"docutils literal\"><span class=\"pre\">idle-timeout</span></tt>.</dd>\n<dt>SetRequestTimeout</dt>\n<dd>Change the connections <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt>.</dd>\n</dl>\n<p>All these command messages are defined in the <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> companion object.</p>\n</div>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> always passes all received headers back to your application. Additionally the values of\nthe following request headers are interpreted by the client itself:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n</ul>\n<p>All other headers are of no interest to the server layer.</p>\n<p>If your <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> instances include any of the following headers they will be ignored and <em>not</em> rendered into\nthe request going out to the client (as the client sets these request headers itself):</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Host</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">User-Agent</span></tt></li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> <em>sprays</em> higher layers\n(like <em>spray-client</em>) only work with the Content-Type value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"ssl-support\">\n<h2>SSL Support</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> allows outgoing connections to be SSL/TLS encrypted. This is signalled on a\nper-connection basis by setting the <tt class=\"docutils literal\"><span class=\"pre\">tag</span></tt> member of the <tt class=\"docutils literal\"><span class=\"pre\">Connect</span></tt> command to <tt class=\"docutils literal\"><span class=\"pre\">HttpClient.SslEnabled</span></tt>.</p>\n<p>The constructor of the <tt class=\"docutils literal\"><span class=\"pre\">HttpClient</span></tt> actor takes an implicit argument of type <tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt>, which is\nessentially a function <tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">SSLEngine</span></tt>. Whenever a new connection has been accepted the client uses\nthe given function to create an <tt class=\"docutils literal\"><span class=\"pre\">javax.net.ssl.SSLEngine</span></tt> for the connection.</p>\n<p>If you&#8217;d like to apply some custom configuration to your <tt class=\"docutils literal\"><span class=\"pre\">SSLEngine</span></tt> instances an easy way would be to bring a custom\nengine provider into scope, e.g. like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">myEngineProvider</span> <span class=\"k\">=</span> <span class=\"nc\">ClientSSLEngineProvider</span> <span class=\"o\">{</span> <span class=\"n\">engine</span> <span class=\"k\">=&gt;</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledCipherSuites</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledProtocols</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;SSLv3&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;TLSv1&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>EngineProvider creation also relies on an implicitly available <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt>, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">SSLContextProvider</span> <span class=\"k\">extends</span> <span class=\"o\">(</span><span class=\"nc\">PipelineContext</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">SSLContext</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>The default <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt> simply provides an implicitly available &#8220;constant&#8221; <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>, by default the\n<tt class=\"docutils literal\"><span class=\"pre\">SSLContext.getDefault</span></tt> is used. This means that the easiest way to have the server use a custom <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>\nis to simply bring one into scope implicitly:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">mySSLContext</span><span class=\"k\">:</span> <span class=\"kt\">SSLContext</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">context</span> <span class=\"k\">=</span> <span class=\"nc\">SSLContext</span><span class=\"o\">.</span><span class=\"n\">getInstance</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS&quot;</span><span class=\"o\">)</span>\n  <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"o\">(...)</span>\n  <span class=\"n\">context</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "HttpClient", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-can/http-client", "next": {"link": "../http-dialog/", "title": "HttpDialog"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/http-dialog", "HttpDialog", "N", "next"], ["documentation/spray-can/http-server", "HttpServer", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-can"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">HttpClient</a><ul>\n<li><a class=\"reference internal\" href=\"#basic-architecture\">Basic Architecture</a></li>\n<li><a class=\"reference internal\" href=\"#starting-and-stopping\">Starting and Stopping</a></li>\n<li><a class=\"reference internal\" href=\"#message-protocol\">Message Protocol</a><ul>\n<li><a class=\"reference internal\" href=\"#chunked-requests\">Chunked Requests</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#request-timeouts\">Request Timeouts</a></li>\n<li><a class=\"reference internal\" href=\"#send-confirmations\">Send Confirmations</a></li>\n<li><a class=\"reference internal\" href=\"#closed-notifications\">Closed Notifications</a></li>\n<li><a class=\"reference internal\" href=\"#connection-configuration\">Connection Configuration</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#ssl-support\">SSL Support</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../http-server/", "title": "HttpServer"}, "metatags": ""}