{"body": "<div class=\"section\" id=\"pipelining\">\n<span id=\"id1\"></span><h1>Pipelining</h1>\n<p>In order to form a proper foundation for architecturally sound network client- and server implementations <em>spray-io</em>\nsupports <em>pipelining</em>. The basic idea is to design a client or server as a series of loosely coupled <em>pipeline stages</em>,\nwith each stage implementing only one tightly scoped aspect of the whole logic.\nPipeline stages can be assembled into different configurations in way that is configurable at runtime, which allows\na user of the client or server to enable or disable selected parts according to their needs.</p>\n<p>The <em>spray-io</em> pipelining architecture is loosely based on the one from <a class=\"reference external\" href=\"http://www.jboss.org/netty\">Netty</a>. However, in contrast to its Java-based\n&#8220;role model&#8221; it can leverage Scala language features such as pattern matching for a cleaner and more concise\nimplementation without sacrificing performance.</p>\n<div class=\"section\" id=\"architecture\">\n<h2>Architecture</h2>\n<p>The following diagram outlines the major concepts:</p>\n<img src=\"../../../_images/pipelining.svg\" /><p>When a connection actor is started by its parent (which is either an <a class=\"reference internal\" href=\"../io-client/#ioclient\"><em>IOClient</em></a> or an <a class=\"reference internal\" href=\"../io-server/#ioserver\"><em>IOServer</em></a>) it\nimmediately constructs two &#8220;pipelines&#8221;, a <em>command pipeline</em> and an <em>event pipeline</em>. A pipeline consists of one or\nmore <em>pipeline stages</em>, through which messages travel unidirectionally.</p>\n<p>In the command pipeline <tt class=\"docutils literal\"><span class=\"pre\">Command</span></tt> messages are passed from higher-level stages down to lower-level stages until they\nhit the final stage, which, in most cases, passes them on to the underlying <a class=\"reference internal\" href=\"../io-bridge/#iobridge\"><em>IOBridge</em></a>. In the event pipeline\n<tt class=\"docutils literal\"><span class=\"pre\">Event</span></tt> message flow in the other direction, from the <a class=\"reference internal\" href=\"../io-bridge/#iobridge\"><em>IOBridge</em></a> up through all its stages.</p>\n<p>Pipeline stages form the entities, into which you typically structure your client or server logic. Conceptually there\nare four types of stages:</p>\n<ul class=\"simple\">\n<li>&#8220;Command-only stages&#8221;, which inject logic only into the command pipeline</li>\n<li>&#8220;Event-only stages&#8221;, which inject logic only into the event pipeline</li>\n<li>&#8220;Full stages&#8221;, which inject logic into both pipelines</li>\n<li>&#8220;Empty stages&#8221;, which don&#8217;t add any logic (they serve as neutral element for pipeline combination)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"the-pipelinestage-trait\">\n<h2>The <em>PipelineStage</em> trait</h2>\n<p>Pipeline stages are modelled by the <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> trait, whose central element is the <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">build</span><span class=\"o\">(</span><span class=\"n\">context</span><span class=\"k\">:</span> <span class=\"kt\">PipelineContext</span><span class=\"o\">,</span>\n          <span class=\"n\">commandPL</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Command</span><span class=\"o\">],</span>\n          <span class=\"n\">eventPL</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Event</span><span class=\"o\">])</span><span class=\"k\">:</span> <span class=\"kt\">Pipelines</span>\n</pre></div>\n</div>\n<p>whereby <tt class=\"docutils literal\"><span class=\"pre\">Pipeline</span></tt> is the following simple type alias:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">type</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">-T</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"n\">T</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">Unit</span>\n</pre></div>\n</div>\n<p>So, when seen from the outside, a pipeline appears simply as a sink for messages of specific type.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method of a <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> is called every time a new connection actor is created. Apart from the\n<tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span></tt> the <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method receives its downstream &#8220;tail&#8221; pipelines as arguments.\nThe result of the <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method is an instance of the <tt class=\"docutils literal\"><span class=\"pre\">Pipelines</span></tt> trait, which simply groups together the new\ncommand and event pipelines, after the stage has prepended them with its own logic:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">Pipelines</span> <span class=\"o\">{</span>\n  <span class=\"k\">def</span> <span class=\"n\">commandPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Command</span><span class=\"o\">]</span>\n  <span class=\"k\">def</span> <span class=\"n\">eventPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Event</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>The dotted lines in the following diagram illustrate what the <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method returns:</p>\n<img src=\"../../../_images/PipelineStage.svg\" /></div>\n<div class=\"section\" id=\"execution-model\">\n<h2>Execution Model</h2>\n<p>Since pipelines are simple functions <tt class=\"docutils literal\"><span class=\"pre\">T</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Unit</span></tt> (with <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> being either <tt class=\"docutils literal\"><span class=\"pre\">Command</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">Event</span></tt>) each stage is\nin complete control of the message flow. It can not only modify messages, it can also hold, discard or multiply them in\nany way. Additionally it can generate messages of the opposite type and push them into the respective downstream tail\npipeline. For example, the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/server/RequestParsing.scala\">RequestParsing</a> stage of the <a class=\"reference internal\" href=\"../../spray-can/#spray-can\"><em>spray-can</em></a> <a class=\"reference internal\" href=\"../../spray-can/http-server/#httpserver\"><em>HttpServer</em></a> generates commands\nthat complete a request with an error response whenever a request parsing error is encountered.</p>\n<p>Also, all pipeline code is always executed in the context of the connection actor and therefore isolated to a specific\nconnection. As such, keeping mutable, connection-specific state within a pipeline stage is not a problem.</p>\n<p>When another actor gets a hold of the connection actors <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> (e.g. because a pipeline stage sent an\n<tt class=\"docutils literal\"><span class=\"pre\">IOPeer.Tell</span></tt> command using the connection actor as <tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt>) and itself sends a message to the connection actor,\nthis message hits the connection actors <tt class=\"docutils literal\"><span class=\"pre\">receive</span></tt> behavior, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">receive</span><span class=\"k\">:</span> <span class=\"kt\">Receive</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">Command</span> <span class=\"o\">=&gt;</span> <span class=\"n\">pipelines</span><span class=\"o\">.</span><span class=\"n\">commandPipeline</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">Event</span> <span class=\"o\">=&gt;</span> <span class=\"n\">pipelines</span><span class=\"o\">.</span><span class=\"n\">eventPipeline</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"nc\">Status</span><span class=\"o\">.</span><span class=\"nc\">Failure</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">CommandException</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">pipelines</span><span class=\"o\">.</span><span class=\"n\">eventPipeline</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"nc\">Terminated</span><span class=\"o\">(</span><span class=\"n\">actor</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">pipelines</span><span class=\"o\">.</span><span class=\"n\">eventPipeline</span><span class=\"o\">(</span><span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">ActorDeath</span><span class=\"o\">(</span><span class=\"n\">actor</span><span class=\"o\">))</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>As you can see the connection actor feeds all incoming <tt class=\"docutils literal\"><span class=\"pre\">Command</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">Event</span></tt> messages directly into its respective\npipeline. This behavior can also be useful from within a pipeline stage itself, because it allows any stage to push a\ncommand or event into the <em>beginning</em> of the respective pipeline, rather than just its own downstream pipeline &#8220;tail&#8221;.\nAll that stage has to do is to send the message to its own connection actor.</p>\n</div>\n<div class=\"section\" id=\"creating-pipeline-stages\">\n<h2>Creating Pipeline Stages</h2>\n<p>Since the <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> trait is a regular Scala trait you can implement it in any way you like. However, the\nfollowing template, which illustrates how pipeline stage implementations within <em>spray</em> itself are\nstructured, might give you a good starting point:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">object</span> <span class=\"nc\">PipelineStageName</span> <span class=\"o\">{</span>\n\n  <span class=\"c1\">// members defined here are global across</span>\n  <span class=\"c1\">// all server and client instances</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">apply</span><span class=\"o\">(&lt;</span><span class=\"n\">arguments</span><span class=\"o\">&gt;)</span><span class=\"k\">:</span> <span class=\"kt\">PipelineStage</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">PipelineStage</span> <span class=\"o\">{</span>\n    <span class=\"n\">require</span><span class=\"o\">(...)</span> <span class=\"c1\">// argument verification</span>\n\n    <span class=\"c1\">// members defined here exist once per</span>\n    <span class=\"c1\">// server or client instance</span>\n\n    <span class=\"k\">def</span> <span class=\"n\">build</span><span class=\"o\">(</span><span class=\"n\">context</span><span class=\"k\">:</span> <span class=\"kt\">PipelineContext</span><span class=\"o\">,</span>\n              <span class=\"n\">commandPL</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Command</span><span class=\"o\">],</span>\n              <span class=\"n\">eventPL</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Event</span><span class=\"o\">])</span><span class=\"k\">:</span> <span class=\"kt\">Pipelines</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Pipelines</span> <span class=\"o\">{</span>\n\n      <span class=\"c1\">// members defined here exist</span>\n      <span class=\"c1\">// once per connection</span>\n\n      <span class=\"k\">val</span> <span class=\"n\">commandPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Command</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n        <span class=\"k\">case</span> <span class=\"o\">...</span> <span class=\"k\">=&gt;</span>\n          <span class=\"c1\">// handle &quot;interesting&quot; commands, send commands</span>\n          <span class=\"c1\">// and events to the commandPL or eventPL</span>\n\n        <span class=\"k\">case</span> <span class=\"n\">cmd</span> <span class=\"k\">=&gt;</span> <span class=\"c1\">// pass through all &quot;unknown&quot; commands</span>\n          <span class=\"n\">commandPL</span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"o\">)</span>\n      <span class=\"o\">}</span>\n\n      <span class=\"k\">val</span> <span class=\"n\">eventPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Event</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n        <span class=\"k\">case</span> <span class=\"o\">...</span> <span class=\"k\">=&gt;</span>\n          <span class=\"c1\">// handle &quot;interesting&quot; events, send commands</span>\n          <span class=\"c1\">// and events to the commandPL or eventPL</span>\n\n        <span class=\"k\">case</span> <span class=\"n\">ev</span> <span class=\"k\">=&gt;</span> <span class=\"c1\">// pass through all &quot;unknown&quot; events</span>\n          <span class=\"n\">eventPL</span><span class=\"o\">(</span><span class=\"n\">ev</span><span class=\"o\">)</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"c1\">////////////// COMMANDS and EVENTS //////////////</span>\n\n  <span class=\"c1\">// definition of all commands and events specific to this pipeline stage</span>\n\n  <span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">MyCommand</span><span class=\"o\">(...)</span> <span class=\"k\">extends</span> <span class=\"nc\">Command</span>\n  <span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">MyEvent</span><span class=\"o\">(...)</span> <span class=\"k\">extends</span> <span class=\"nc\">Event</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>This template shows a &#8220;full stage``, with logic injected into both pipelines. If your stage only requires logic in one\nof the pipelines simply pass through the other one unchanged. For example, if your stage is a &#8220;command-only&#8221; stage you&#8217;d\nimplement the <tt class=\"docutils literal\"><span class=\"pre\">eventPipeline</span></tt> member of the <tt class=\"docutils literal\"><span class=\"pre\">Pipelines</span></tt> trait as such:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">eventPipeline</span> <span class=\"k\">=</span> <span class=\"n\">eventPL</span>\n</pre></div>\n</div>\n<p>Check out the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/server/ResponseRendering.scala\">ResponseRendering</a> stage of the <a class=\"reference internal\" href=\"../../spray-can/#spray-can\"><em>spray-can</em></a> <a class=\"reference internal\" href=\"../../spray-can/http-server/#httpserver\"><em>HttpServer</em></a> as an\nexample of a &#8220;command-only stage&#8221; and the <a class=\"reference internal\" href=\"../predefined-stages/#tickgenerator\"><em>TickGenerator</em></a> as an &#8220;event-only stage&#8221; example.</p>\n</div>\n<div class=\"section\" id=\"combining-pipeline-stages\">\n<h2>Combining Pipeline Stages</h2>\n<p>Two <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> instances can be combined into single one with the <tt class=\"docutils literal\"><span class=\"pre\">&gt;&gt;</span></tt> operator. Additionally an expression\ncreating a <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> can be made optional by prepending it with a <tt class=\"docutils literal\"><span class=\"pre\">&lt;boolean&gt;</span> <span class=\"pre\">?</span></tt> modifier.</p>\n<p>To understand what this means check out this simplified version of the definition of the <a class=\"reference internal\" href=\"../../spray-can/#spray-can\"><em>spray-can</em></a>\n<a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-can/src/main/scala/spray/can/client/HttpClient.scala\">HttpClient</a> pipeline:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"nc\">ClientFrontend</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"o\">(</span><span class=\"nc\">ResponseChunkAggregationLimit</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"nc\">ResponseChunkAggregation</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"nc\">ResponseParsing</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"nc\">RequestRendering</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"nc\">IdleTimeout</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"nc\">ConnectionTimeouts</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"nc\">SslTlsSupport</span><span class=\"o\">(...)</span> <span class=\"o\">&gt;&gt;</span>\n<span class=\"o\">(</span><span class=\"nc\">ReapingCycle</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nc\">IdleTimeout</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"nc\">TickGenerator</span><span class=\"o\">(</span><span class=\"nc\">ReapingCycle</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>This expression constructs a single <tt class=\"docutils literal\"><span class=\"pre\">PipelineStage</span></tt> instance from 3 to 7 sub-stages, depending on the configuration\nsettings of the client. The lines containing a <tt class=\"docutils literal\"><span class=\"pre\">?</span></tt> operator evaluate to <tt class=\"docutils literal\"><span class=\"pre\">EmptyPipelineStage</span></tt> if the boolean\nexpression before the <tt class=\"docutils literal\"><span class=\"pre\">?</span></tt> is false. The <tt class=\"docutils literal\"><span class=\"pre\">EmptyPipelineStage</span></tt> singleton object serves as a &#8220;neutral&#8221; element when\ncombining pipeline stages. Its <tt class=\"docutils literal\"><span class=\"pre\">build</span></tt> method doesn&#8217;t append any logic to either pipeline, so &#8220;switched off&#8221;\nPipelineStages do not introduce any overhead.</p>\n</div>\n<div class=\"section\" id=\"the-final-stages\">\n<h2>The Final Stages</h2>\n<p>Both pipelines, the command as well as the event pipeline, are always terminated by stages provided by the connection\nactor itself. The following, an excerpt of the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/v1.1-M7/spray-io/src/main/scala/spray/io/ConnectionActors.scala\">IOConnectionActor sources</a>, is their definition:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">baseCommandPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Command</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">Send</span><span class=\"o\">(</span><span class=\"n\">buffers</span><span class=\"o\">,</span> <span class=\"n\">ack</span><span class=\"o\">)</span>          <span class=\"k\">=&gt;</span> <span class=\"n\">ioBridge</span> <span class=\"o\">!</span> <span class=\"nc\">IOBridge</span><span class=\"o\">.</span><span class=\"nc\">Send</span><span class=\"o\">(</span><span class=\"n\">connection</span><span class=\"o\">,</span> <span class=\"n\">buffers</span><span class=\"o\">,</span> <span class=\"n\">eventize</span><span class=\"o\">(</span><span class=\"n\">ack</span><span class=\"o\">))</span>\n  <span class=\"k\">case</span> <span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">Close</span><span class=\"o\">(</span><span class=\"n\">reason</span><span class=\"o\">)</span>               <span class=\"k\">=&gt;</span> <span class=\"n\">ioBridge</span> <span class=\"o\">!</span> <span class=\"nc\">IOBridge</span><span class=\"o\">.</span><span class=\"nc\">Close</span><span class=\"o\">(</span><span class=\"n\">connection</span><span class=\"o\">,</span> <span class=\"n\">reason</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">StopReading</span>                 <span class=\"k\">=&gt;</span> <span class=\"n\">ioBridge</span> <span class=\"o\">!</span> <span class=\"nc\">IOBridge</span><span class=\"o\">.</span><span class=\"nc\">StopReading</span><span class=\"o\">(</span><span class=\"n\">connection</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">ResumeReading</span>               <span class=\"k\">=&gt;</span> <span class=\"n\">ioBridge</span> <span class=\"o\">!</span> <span class=\"nc\">IOBridge</span><span class=\"o\">.</span><span class=\"nc\">ResumeReading</span><span class=\"o\">(</span><span class=\"n\">connection</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"nc\">IOPeer</span><span class=\"o\">.</span><span class=\"nc\">Tell</span><span class=\"o\">(</span><span class=\"n\">receiver</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">sender</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">receiver</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"o\">(</span><span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">sender</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"k\">_:</span> <span class=\"kt\">Droppable</span> <span class=\"o\">=&gt;</span> <span class=\"c1\">// don&#39;t warn</span>\n  <span class=\"k\">case</span> <span class=\"n\">cmd</span> <span class=\"k\">=&gt;</span> <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">warning</span><span class=\"o\">(</span><span class=\"s\">&quot;commandPipeline: dropped {}&quot;</span><span class=\"o\">,</span> <span class=\"n\">cmd</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">def</span> <span class=\"n\">baseEventPipeline</span><span class=\"k\">:</span> <span class=\"kt\">Pipeline</span><span class=\"o\">[</span><span class=\"kt\">Event</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">IOPeer.Closed</span> <span class=\"o\">=&gt;</span> <span class=\"n\">stop</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">case</span> <span class=\"k\">_:</span> <span class=\"kt\">Droppable</span> <span class=\"o\">=&gt;</span> <span class=\"c1\">// don&#39;t warn</span>\n  <span class=\"k\">case</span> <span class=\"n\">ev</span> <span class=\"k\">=&gt;</span> <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">warning</span><span class=\"o\">(</span><span class=\"s\">&quot;eventPipeline: dropped {}&quot;</span><span class=\"o\">,</span> <span class=\"n\">ev</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>The final stage of the command pipeline translates most of the defined messages into their <tt class=\"docutils literal\"><span class=\"pre\">IOBridge</span></tt> counterparts\nand sends them off to the bridge. There is one command, <tt class=\"docutils literal\"><span class=\"pre\">IOPeer.Tell</span></tt>, which does not follow this pattern.\nThis command simply encapsulates an Actor <tt class=\"docutils literal\"><span class=\"pre\">tell</span></tt> call into a <tt class=\"docutils literal\"><span class=\"pre\">Command</span></tt> message. Whenever a pipeline stage would like\nto send a message to an actor it should push an <tt class=\"docutils literal\"><span class=\"pre\">IOPeer.Tell</span></tt> command into the command pipeline rather than\ncalling <tt class=\"docutils literal\"><span class=\"pre\">actorRef.tell</span></tt> directly. This design has two benefits:</p>\n<ul class=\"simple\">\n<li>Other downstream pipeline stages can react to, and maybe even modify the <tt class=\"docutils literal\"><span class=\"pre\">Tell</span></tt>.</li>\n<li>The stage remains independently testable, without the need to fire up actors. (Check out the <a class=\"reference internal\" href=\"../testing-pipelines/#testing-pipelines\"><em>Testing Pipelines</em></a>\nchapter for more info on this.)</li>\n</ul>\n<p>The final stage of the event pipeline only reacts to <tt class=\"docutils literal\"><span class=\"pre\">Closed</span></tt> messages. It stops the connection actor as a result.</p>\n</div>\n</div>\n", "display_toc": true, "title": "Pipelining", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-io/pipelining", "next": {"link": "../predefined-stages/", "title": "Predefined Stages"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-io/predefined-stages", "Predefined Stages", "N", "next"], ["documentation/spray-io/connection-actors", "ConnectionActors", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-io"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Pipelining</a><ul>\n<li><a class=\"reference internal\" href=\"#architecture\">Architecture</a></li>\n<li><a class=\"reference internal\" href=\"#the-pipelinestage-trait\">The <em>PipelineStage</em> trait</a></li>\n<li><a class=\"reference internal\" href=\"#execution-model\">Execution Model</a></li>\n<li><a class=\"reference internal\" href=\"#creating-pipeline-stages\">Creating Pipeline Stages</a></li>\n<li><a class=\"reference internal\" href=\"#combining-pipeline-stages\">Combining Pipeline Stages</a></li>\n<li><a class=\"reference internal\" href=\"#the-final-stages\">The Final Stages</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../connection-actors/", "title": "ConnectionActors"}, "metatags": ""}